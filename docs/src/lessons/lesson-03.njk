---
layout: lesson-layout.njk
permalink: lessons/lesson-03.html
lessonNumber: 3
lessonTitle: "Servers Are So 2010 (Go Serverless!)"
duration: "~6 hours"
cost: "~$0.50"
stepNumber: 1
totalSteps: 5
progress: 20
title: "Lesson 3: Servers Are So 2010 - AWS Learning Tutorial"
tocContent: |
  <li class="active">
  <a href="lesson-03.html">
  <span class="step-number">1</span>
  <span class="step-title">DynamoDB Database</span>
  </a>
  </li>
  <li>
  <a href="lesson-03-2.html">
  <span class="step-number">2</span>
  <span class="step-title">Lambda Functions</span>
  </a>
  </li>
  <li>
  <a href="lesson-03-3.html">
  <span class="step-number">3</span>
  <span class="step-title">API Gateway</span>
  </a>
  </li>
  <li>
  <a href="lesson-03-4.html">
  <span class="step-number">4</span>
  <span class="step-title">Test Your API</span>
  </a>
  </li>
  <li>
  <a href="lesson-03-5.html">
  <span class="step-number">5</span>
  <span class="step-title">Monitoring &amp; Cleanup</span>
  </a>
  </li>
---

<div class="step-header">
        <span class="step-badge">Lesson 3 - Part 1</span>
        <h1>Servers Are So 2010 (Go Serverless!)</h1>
      </div>

      <div class="step-content">
        <h2>What You're Building</h2>
        <p>Build a fully serverless REST API without managing a single server. You'll create a URL shortener service using Lambda functions, API Gateway, and DynamoDB. No servers to patch, no capacity planning, no SSH keys - just code that scales automatically from zero to millions of requests.</p>

        <h2>What You'll Learn</h2>
        <ul>
          <li><strong>Lambda</strong>: Run code without servers</li>
          <li><strong>API Gateway</strong>: HTTP endpoints for your functions</li>
          <li><strong>DynamoDB</strong>: NoSQL database that scales automatically</li>
          <li><strong>IAM Roles</strong>: Fine-grained permissions for Lambda</li>
          <li><strong>CloudWatch Logs</strong>: Debugging serverless apps</li>
          <li><strong>Serverless architecture</strong>: When to use it (and when not to)</li>
        </ul>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>What is Lambda (Serverless Computing)?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> Lambda lets you run code without provisioning or managing servers. You upload your function code, and AWS runs it when triggered, automatically scaling from zero to thousands of concurrent executions.</p>

            <p><strong>Why we need it:</strong> Traditional servers waste resources sitting idle and require constant maintenance (patching, scaling, monitoring). Lambda only runs when needed and AWS handles all the infrastructure, so you focus purely on your code.</p>

            <p><strong>Key details:</strong> You pay only per request and compute time (to the millisecond). Each function has a maximum 15-minute timeout. AWS automatically scales it horizontally to handle any number of simultaneous requests.</p>

            <p><strong>Common gotcha:</strong> The first request to a Lambda (cold start) takes longer because AWS needs to provision the runtime environment. Subsequent requests are much faster. Also, Lambda is stateless - any data must be stored externally (like in DynamoDB).</p>
          </div>
        </div>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>What is API Gateway?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> API Gateway creates HTTP endpoints (URLs) that trigger your Lambda functions. It acts as the front door to your serverless application, handling incoming requests and routing them to the right backend service.</p>

            <p><strong>Why we need it:</strong> Lambda functions can't be called directly from the internet - they need a public HTTP interface. API Gateway provides that interface, plus features like authentication, rate limiting, request validation, and response transformation.</p>

            <p><strong>Key details:</strong> It handles REST and HTTP APIs, WebSocket connections, and can integrate with many AWS services beyond Lambda. It automatically scales with traffic and provides built-in DDoS protection and throttling.</p>

            <p><strong>Common gotcha:</strong> Creating an API Gateway doesn't make it live - you must create a "deployment" to a specific "stage" (like prod or dev). Forgetting to deploy means your changes won't be visible to users.</p>
          </div>
        </div>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>What is DynamoDB (NoSQL)?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> DynamoDB is a fully managed NoSQL database that stores data as key-value pairs or documents. Unlike SQL databases with rigid tables and schemas, DynamoDB is schemaless and designed for massive scale and speed.</p>

            <p><strong>Why we need it:</strong> Traditional SQL databases require servers, capacity planning, and manual scaling. DynamoDB handles all infrastructure, scales automatically, and provides single-digit millisecond performance at any scale - perfect for serverless apps.</p>

            <p><strong>Key details:</strong> NoSQL means no relationships or joins - you design your data access patterns upfront. You define a partition key (primary identifier) and optionally a sort key for organizing related items together. PAY_PER_REQUEST billing means you only pay for actual reads/writes.</p>

            <p><strong>Common gotcha:</strong> Coming from SQL, the biggest shift is that you can't do complex queries or joins. You must know your exact access patterns beforehand and design your keys accordingly. Scanning entire tables is expensive and slow.</p>
          </div>
        </div>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>IAM Roles vs Users - What's the Difference?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> IAM Users are for people with long-term credentials (username/password or access keys). IAM Roles are temporary credentials that AWS services (like Lambda) assume to gain permissions.</p>

            <p><strong>Why we need it:</strong> You don't want to hardcode credentials into your Lambda code - that's a security nightmare. Instead, you assign a role to Lambda with specific permissions, and AWS automatically provides temporary credentials that rotate.</p>

            <p><strong>Key details:</strong> Roles use "trust policies" to define who can assume them (like the Lambda service). Once assumed, the role grants its attached permissions. Roles are the recommended way for AWS services to access other services.</p>

            <p><strong>Common gotcha:</strong> After creating a role, it takes a few seconds to propagate through AWS. If you immediately try to use it with Lambda, you might get an error. Wait 10 seconds and try again.</p>
          </div>
        </div>

        <h2>Prerequisites</h2>
        <ul>
          <li>Completed Lessons 1 &amp; 2</li>
          <li>AWS CLI configured</li>
          <li>Node.js or Python installed locally</li>
          <li>Text editor ready</li>
          <li>Comfortable with JSON</li>
        </ul>

        <hr style="margin: 40px 0; border: none; border-top: 2px solid var(--border-color);">

        <h2>What We're Building: URL Shortener API</h2>

        <p><strong>Endpoints</strong>:</p>
        <ul>
          <li><code>POST /shorten</code> - Create short URL</li>
          <li><code>GET /{shortCode}</code> - Redirect to original URL</li>
          <li><code>GET /stats/{shortCode}</code> - View click stats</li>
          <li><code>DELETE /{shortCode}</code> - Delete short URL</li>
        </ul>

        <p><strong>Why a URL shortener?</strong></p>
        <ul>
          <li>Simple enough to understand</li>
          <li>Complex enough to be useful</li>
          <li>Demonstrates CRUD operations</li>
          <li>Real-world use case</li>
        </ul>

        

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>What are CRUD Operations?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> CRUD stands for Create, Read, Update, Delete - the four basic operations you can perform on data. In our URL shortener: Create (shorten a URL), Read (get stats), Update (increment clicks), Delete (remove URL).</p>

            <p><strong>Why we need it:</strong> Almost every application boils down to CRUD operations. Whether you're building a blog, e-commerce site, or social network, you're creating, reading, updating, and deleting data. Mastering CRUD is fundamental to backend development.</p>

            <p><strong>Key details:</strong> CRUD maps to HTTP methods: POST (Create), GET (Read), PUT/PATCH (Update), DELETE (Delete). In REST APIs, these operations act on resources (like /users or /posts). In databases, they map to INSERT, SELECT, UPDATE, DELETE.</p>

            <p><strong>Common gotcha:</strong> Don't confuse HTTP PUT vs PATCH - PUT replaces the entire resource, while PATCH updates specific fields. Also, DELETE should be idempotent - calling it multiple times has the same effect as calling it once.</p>
          </div>
        </div>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>What is a REST API?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> REST (Representational State Transfer) is an architectural style for APIs that uses HTTP methods and URLs to interact with resources. Resources are nouns (like /users or /urls) and HTTP methods are verbs (GET, POST, PUT, DELETE).</p>

            <p><strong>Why we need it:</strong> REST provides a standardized, predictable way to build APIs that any HTTP client can understand. It's stateless (each request is independent), cacheable, and works over standard HTTP, making it universal across platforms and languages.</p>

            <p><strong>Key details:</strong> RESTful URLs are hierarchical (/users/123/posts/456) and use HTTP status codes meaningfully (200 OK, 201 Created, 404 Not Found). Data is typically exchanged as JSON. Each request contains all information needed to process it.</p>

            <p><strong>Common gotcha:</strong> Many "REST" APIs aren't truly RESTful - they're just HTTP APIs. True REST has constraints like statelessness and hypermedia links. But in practice, most people use "REST" to mean "HTTP API with JSON."</p>
          </div>
        </div>

        <hr style="margin: 40px 0; border: none; border-top: 2px solid var(--border-color);">

        <h2>Part 1: DynamoDB - Your Serverless Database (1 hour)</h2>

        <h3>Step 1: Create DynamoDB Table</h3>
        <pre><code class="language-bash"># Create table for URL mappings
aws dynamodb create-table \
  --table-name url-shortener \
  --attribute-definitions \
    AttributeName=shortCode,AttributeType=S \
  --key-schema \
    AttributeName=shortCode,KeyType=HASH \
  --billing-mode PAY_PER_REQUEST \
  --tags Key=Project,Value=URLShortener

# Wait for table to be active
aws dynamodb wait table-exists --table-name url-shortener

# Verify table exists
aws dynamodb describe-table --table-name url-shortener</code></pre>

        <p><strong>What's happening?</strong></p>
        <ul>
          <li><code>shortCode</code> is our partition key (unique identifier)</li>
          <li><code>PAY_PER_REQUEST</code> means we only pay for what we use (no provisioned capacity)</li>
          <li>No servers, no capacity planning, instant scaling</li>
        </ul>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>What is a Partition Key?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> The partition key is the primary identifier for items in DynamoDB. It determines which physical storage partition your data lives on. Think of it like a unique ID or primary key in SQL databases - no two items can have the same partition key.</p>

            <p><strong>Why we need it:</strong> DynamoDB distributes data across multiple servers for scale and performance. The partition key tells DynamoDB where to store and retrieve your data. All reads and writes using the partition key are fast and efficient (single-digit milliseconds).</p>

            <p><strong>Key details:</strong> Choose partition keys with high cardinality (many unique values) to distribute load evenly. For our URL shortener, each shortCode is unique. If you use a low-cardinality key (like "status: active"), all items go to one partition, creating a bottleneck.</p>

            <p><strong>Common gotcha:</strong> You can't change the partition key after creating a table - you'd have to create a new table and migrate data. Also, you can only query by partition key efficiently. Searching by other attributes requires expensive scans unless you create secondary indexes.</p>
          </div>
        </div>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>What do AttributeType S/N/B Mean?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> DynamoDB attribute types define the data type of your keys. S = String, N = Number, B = Binary. For our shortCode, we use S because it's text like "abc123". Numbers like click counts use N, and binary data (images, files) uses B.</p>

            <p><strong>Why we need it:</strong> DynamoDB needs to know the type to properly sort, compare, and index your keys. The type affects how DynamoDB stores and retrieves the data. For example, numbers stored as strings would sort incorrectly ("10" comes before "2" alphabetically).</p>

            <p><strong>Key details:</strong> These types only apply to keys (partition and sort keys). For non-key attributes, DynamoDB is schemaless - you can store whatever you want. Numbers in DynamoDB support up to 38 digits of precision and can be positive, negative, or zero.</p>

            <p><strong>Common gotcha:</strong> If you store numbers as strings ({"clicks": "0"} instead of {"clicks": 0}), you can't do mathematical operations like incrementing. Always use the correct type for your data.</p>
          </div>
        </div>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>What's the Difference: KeyType HASH vs RANGE?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> HASH is the partition key (primary unique identifier). RANGE is an optional sort key that groups related items together. Together they form a composite key. In our table we only use HASH, but you could add a RANGE key like "timestamp" to track URL history.</p>

            <p><strong>Why we need it:</strong> HASH alone means one item per key. HASH + RANGE lets you store multiple related items. Example: partition key = "user123", sort key = "post-2024-01-15" lets you store many posts per user and query them in chronological order.</p>

            <p><strong>Key details:</strong> With HASH + RANGE, items with the same partition key are stored together and sorted by the range key. You can query ranges like "all posts between date X and Y" efficiently. Only the combination of both keys must be unique.</p>

            <p><strong>Common gotcha:</strong> Many beginners use only HASH when they need HASH + RANGE. If you find yourself creating unique IDs by concatenating values (like "user123-post456"), you probably want a composite key instead.</p>
          </div>
        </div>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>PAY_PER_REQUEST vs PROVISIONED Billing?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> PAY_PER_REQUEST charges per individual read/write operation. PROVISIONED charges for reserved capacity (reads/writes per second) whether you use it or not. PAY_PER_REQUEST is like paying for each coffee you drink; PROVISIONED is like an all-you-can-drink subscription.</p>

            <p><strong>Why we need it:</strong> Different workloads have different cost profiles. PAY_PER_REQUEST is perfect for unpredictable traffic or low-traffic apps - you pay nothing when idle. PROVISIONED is cheaper at high, consistent traffic because the per-operation cost is lower.</p>

            <p><strong>Key details:</strong> PAY_PER_REQUEST auto-scales instantly without configuration. PROVISIONED requires you to set read/write capacity units, and you pay for unused capacity. You can switch between modes once every 24 hours.</p>

            <p><strong>Common gotcha:</strong> Beginners often overprovision capacity "just to be safe," wasting money. Start with PAY_PER_REQUEST for simplicity. Only switch to PROVISIONED if you have steady traffic and can prove it's cheaper (usually above 100+ requests/sec sustained).</p>
          </div>
        </div>

        <h3>Step 2: Test DynamoDB</h3>
        <pre><code class="language-bash"># Put an item
aws dynamodb put-item \
  --table-name url-shortener \
  --item '{
    "shortCode": {"S": "test123"},
    "originalUrl": {"S": "https://example.com"},
    "createdAt": {"N": "1234567890"},
    "clicks": {"N": "0"}
  }'

# Get the item
aws dynamodb get-item \
  --table-name url-shortener \
  --key '{"shortCode": {"S": "test123"}}'

# Scan table (see all items)
aws dynamodb scan --table-name url-shortener</code></pre>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>Why is DynamoDB Item Syntax So Verbose?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> DynamoDB's low-level API requires explicit type annotations like {"S": "value"} for strings and {"N": "123"} for numbers. The S/N/B prefixes tell DynamoDB exactly what data type each attribute is.</p>

            <p><strong>Why we need it:</strong> DynamoDB stores data in a binary format for speed and efficiency. The type markers ensure data is serialized correctly. This low-level format also supports features like conditional updates and atomic counters that require precise type information.</p>

            <p><strong>Key details:</strong> The AWS SDK provides a Document Client that handles type conversion automatically - you can write normal JSON objects and it adds the type markers. In Lambda code, we use @aws-sdk/lib-dynamodb which gives us the simpler syntax.</p>

            <p><strong>Common gotcha:</strong> Mixing up the low-level API (put-item with type markers) and the Document Client (simple JSON) causes confusion. When using the CLI, you must use type markers. In code with the Document Client, you don't. Stick to one approach to avoid errors.</p>
          </div>
        </div>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">ðŸ“˜</span>
            <strong>Scan vs Query - When to Use Each?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> Scan reads every item in the table and optionally filters them. Query finds items by partition key (and optionally sort key range). Scan is like searching every file on your computer; Query is like looking in a specific folder.</p>

            <p><strong>Why we need it:</strong> Query is fast and cheap because it goes directly to the partition with your data. Scan is slow and expensive because it reads everything. For 1 million items, Query returns in milliseconds; Scan could take minutes and cost dollars.</p>

            <p><strong>Key details:</strong> Always use Query when you know the partition key. Scan is only appropriate for small tables, analytics, backups, or when you truly need every item. Scan can consume all your provisioned capacity, causing throttling for other operations.</p>

            <p><strong>Common gotcha:</strong> Beginners use Scan because it seems simpler - no need to specify keys. But this creates performance disasters at scale. If you find yourself using Scan regularly, your table design is probably wrong. Redesign with proper keys and secondary indexes.</p>
          </div>
        </div>

        <p><strong>DynamoDB is working!</strong> Now let's add Lambda functions.</p>
      </div>

      <!-- Navigation -->
      <div class="step-navigation">
        <div class="nav-button-group">
          <a href="../index.html" class="btn btn-secondary">Back to Home</a>
          <a href="lesson-03-2.html" class="btn btn-primary">Next: Lambda Functions â†’</a>
        </div>
      </div>