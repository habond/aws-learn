---
layout: lesson-layout.njk
permalink: lessons/lesson-05-3.html
lessonNumber: 5
lessonTitle: "Containers Are Taking Over"
duration: "~8 hours"
cost: "$2-3"
stepNumber: 3
totalSteps: 7
progress: 42.86
title: "Lesson 5: ECS Cluster with Fargate - AWS Learning Tutorial"
tocContent: |
  <li>
  <a href="lesson-05.html">
  <span class="step-number">1</span>
  <span class="step-title">Docker Basics</span>
  </a>
  </li>
  <li>
  <a href="lesson-05-2.html">
  <span class="step-number">2</span>
  <span class="step-title">Push to ECR</span>
  </a>
  </li>
  <li class="active">
  <a href="lesson-05-3.html">
  <span class="step-number">3</span>
  <span class="step-title">ECS Cluster with Fargate</span>
  </a>
  </li>
  <li>
  <a href="lesson-05-4.html">
  <span class="step-number">4</span>
  <span class="step-title">Application Load Balancer</span>
  </a>
  </li>
  <li>
  <a href="lesson-05-5.html">
  <span class="step-number">5</span>
  <span class="step-title">ECS Service</span>
  </a>
  </li>
  <li>
  <a href="lesson-05-6.html">
  <span class="step-number">6</span>
  <span class="step-title">Scaling and Updates</span>
  </a>
  </li>
  <li>
  <a href="lesson-05-7.html">
  <span class="step-number">7</span>
  <span class="step-title">Monitoring + Cleanup</span>
  </a>
  </li>
---

<div class="step-header">
        <span class="step-badge">Lesson 5 - Part 3</span>
        <h1>ECS Cluster with Fargate</h1>
      </div>

      <div class="step-content">
        <h2>Part 3: ECS Cluster with Fargate (2 hours)</h2>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">üìò</span>
            <strong>What are ECS and Fargate?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> ECS (Elastic Container Service) is AWS's container orchestration service - it manages running containers, health checks, scaling, and load balancing. Fargate is a launch type for ECS that runs containers without you managing servers. With Fargate, you just say "run this container" and AWS handles the underlying infrastructure.</p>

            <p><strong>Why we need it:</strong> Running a container once is easy (docker run). But production needs automated restarts if containers crash, load balancing across multiple containers, rolling deployments, and auto-scaling. ECS provides all this orchestration. Fargate adds serverless convenience - no EC2 instances to patch or manage.</p>

            <p><strong>Key details:</strong> An ECS cluster is a logical grouping of tasks and services. A task definition is the blueprint (which image, how much CPU/memory, environment variables). A task is a running instance of that definition. A service ensures a specified number of tasks are always running and handles load balancing.</p>

            <p><strong>Common gotcha:</strong> Fargate costs are based on CPU and memory allocated, not used. If you allocate 1GB memory but only use 500MB, you pay for 1GB. Also, Fargate tasks need awsvpc network mode, which gives each task its own elastic network interface - this is different from traditional Docker networking.</p>
          </div>
        </div>

        <h3>Step 8: Create ECS Cluster</h3>
        <pre><code class="language-bash"># Create cluster
aws ecs create-cluster --cluster-name task-manager-cluster

# Verify cluster
aws ecs describe-clusters --clusters task-manager-cluster</code></pre>

        <h3>Step 9: Create Task Execution Role</h3>
        <p>ECS needs permissions to pull images from ECR and write logs.</p>
        <pre><code class="language-bash"># Create trust policy
cat &gt; ecs-task-trust-policy.json &lt;&lt; 'EOF'
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ecs-tasks.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
EOF

# Create execution role
aws iam create-role \
  --role-name ecsTaskExecutionRole \
  --assume-role-policy-document file://ecs-task-trust-policy.json

# Attach AWS managed policy
aws iam attach-role-policy \
  --role-name ecsTaskExecutionRole \
  --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy

# Get role ARN
export EXECUTION_ROLE_ARN=$(aws iam get-role \
  --role-name ecsTaskExecutionRole \
  --query 'Role.Arn' \
  --output text)

echo "Execution Role ARN: $EXECUTION_ROLE_ARN"</code></pre>

        <h3>Step 10: Create CloudWatch Log Group</h3>
        <pre><code class="language-bash"># Create log group for container logs
aws logs create-log-group --log-group-name /ecs/task-manager

# Verify
aws logs describe-log-groups --log-group-name-prefix /ecs/task-manager</code></pre>

        <h3>Step 11: Create Task Definition</h3>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">üìò</span>
            <strong>What is an ECS Task Definition?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> A task definition is a JSON blueprint that describes how to run your containerized application. It specifies which Docker image to use, how much CPU and memory to allocate, networking mode, environment variables, logging configuration, and health checks.</p>

            <p><strong>Why we need it:</strong> Without a task definition, ECS doesn't know how to run your container. It's like a recipe that ECS follows every time it launches your application. Task definitions are versioned - each change creates a new revision, allowing rollbacks if something breaks.</p>

            <p><strong>Key details:</strong> requiresCompatibilities tells ECS this runs on Fargate (vs EC2). awsvpc network mode gives each task its own network interface. executionRoleArn allows ECS to pull images and write logs. The containerDefinitions array can include multiple containers that run together (like app + sidecar).</p>

            <p><strong>Common gotcha:</strong> CPU and memory values have specific valid combinations in Fargate (e.g., 256 CPU units can only be paired with 512MB, 1GB, or 2GB memory). If you pick an invalid combo, task launch will fail with a cryptic error. Check AWS documentation for valid combinations.</p>
          </div>
        </div>

        <pre><code class="language-bash"># Get AWS account ID
export ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

# Create task definition
cat &gt; task-definition.json &lt;&lt; EOF
{
  "family": "task-manager",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "executionRoleArn": "$EXECUTION_ROLE_ARN",
  "containerDefinitions": [
    {
      "name": "task-manager",
      "image": "$ECR_REPO:latest",
      "portMappings": [
        {
          "containerPort": 3000,
          "protocol": "tcp"
        }
      ],
      "essential": true,
      "environment": [
        {
          "name": "NODE_ENV",
          "value": "production"
        },
        {
          "name": "PORT",
          "value": "3000"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/task-manager",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "healthCheck": {
        "command": ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 10
      }
    }
  ]
}
EOF

# Register task definition
aws ecs register-task-definition --cli-input-json file://task-definition.json

# Verify
aws ecs describe-task-definition --task-definition task-manager</code></pre>

        <h3>Step 12: Create Security Group for ECS Tasks</h3>
        <pre><code class="language-bash"># Get default VPC
export VPC_ID=$(aws ec2 describe-vpcs \
  --filters "Name=isDefault,Values=true" \
  --query "Vpcs[0].VpcId" \
  --output text)

# Create security group
aws ec2 create-security-group \
  --group-name task-manager-ecs-sg \
  --description "Security group for Task Manager ECS tasks" \
  --vpc-id $VPC_ID

# Get security group ID
export ECS_SG_ID=$(aws ec2 describe-security-groups \
  --filters "Name=group-name,Values=task-manager-ecs-sg" \
  --query "SecurityGroups[0].GroupId" \
  --output text)

# Allow inbound traffic on port 3000 from anywhere (we'll restrict this with ALB later)
aws ec2 authorize-security-group-ingress \
  --group-id $ECS_SG_ID \
  --protocol tcp \
  --port 3000 \
  --cidr 0.0.0.0/0

echo "ECS Security Group: $ECS_SG_ID"</code></pre>

        <h3>Step 13: Run Task</h3>
        <pre><code class="language-bash"># Get subnet IDs
export SUBNET_IDS=$(aws ec2 describe-subnets \
  --filters "Name=vpc-id,Values=$VPC_ID" \
  --query "Subnets[0:2].SubnetId" \
  --output text | tr '\t' ',')

# Run task
aws ecs run-task \
  --cluster task-manager-cluster \
  --task-definition task-manager \
  --launch-type FARGATE \
  --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$ECS_SG_ID],assignPublicIp=ENABLED}"

# Get task ID
export TASK_ARN=$(aws ecs list-tasks \
  --cluster task-manager-cluster \
  --query 'taskArns[0]' \
  --output text)

# Wait for task to be running
aws ecs wait tasks-running \
  --cluster task-manager-cluster \
  --tasks $TASK_ARN

# Get task details including public IP
aws ecs describe-tasks \
  --cluster task-manager-cluster \
  --tasks $TASK_ARN

# Extract public IP (this is a bit complex)
export TASK_IP=$(aws ecs describe-tasks \
  --cluster task-manager-cluster \
  --tasks $TASK_ARN \
  --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
  --output text | xargs -I {} aws ec2 describe-network-interfaces \
  --network-interface-ids {} \
  --query 'NetworkInterfaces[0].Association.PublicIp' \
  --output text)

echo "Task IP: $TASK_IP"

# Test the task
curl http://$TASK_IP:3000/health
curl http://$TASK_IP:3000/tasks</code></pre>

        <p><strong>Your container is running on Fargate!</strong></p>
      </div>

      <!-- Navigation -->
      <div class="step-navigation">
        <div class="nav-button-group">
          <a href="lesson-05-2.html" class="btn btn-secondary">‚Üê Previous: Push to ECR</a>
          <a href="lesson-05-4.html" class="btn btn-primary">Next: Application Load Balancer ‚Üí</a>
        </div>
      </div>