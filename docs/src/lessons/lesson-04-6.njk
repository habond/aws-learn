---
layout: lesson-layout.njk
permalink: lessons/lesson-04-6.html
lessonNumber: 4
lessonTitle: "Automate All The Things!"
duration: "~7 hours"
cost: "~$1"
stepNumber: 6
totalSteps: 7
progress: 85.68
title: "Lesson 4: Advanced Terraform - AWS Learning Tutorial"
tocContent: |
  <li>
  <a href="lesson-04.html">
  <span class="step-number">1</span>
  <span class="step-title">Overview + Terraform Setup</span>
  </a>
  </li>
  <li>
  <a href="lesson-04-2.html">
  <span class="step-number">2</span>
  <span class="step-title">DynamoDB with Terraform</span>
  </a>
  </li>
  <li>
  <a href="lesson-04-3.html">
  <span class="step-number">3</span>
  <span class="step-title">Lambda Functions</span>
  </a>
  </li>
  <li>
  <a href="lesson-04-4.html">
  <span class="step-number">4</span>
  <span class="step-title">API Gateway</span>
  </a>
  </li>
  <li>
  <a href="lesson-04-5.html">
  <span class="step-number">5</span>
  <span class="step-title">Test &amp; Iterate</span>
  </a>
  </li>
  <li class="active">
  <a href="lesson-04-6.html">
  <span class="step-number">6</span>
  <span class="step-title">Advanced Terraform</span>
  </a>
  </li>
  <li>
  <a href="lesson-04-7.html">
  <span class="step-number">7</span>
  <span class="step-title">Destroy &amp; Rebuild</span>
  </a>
  </li>
---

<div class="step-header">
        <span class="step-badge">Lesson 4 - Part 6</span>
        <h1>Advanced Terraform</h1>
      </div>

      <div class="step-content">
        <h2>Part 6: Advanced Terraform (1.5 hours)</h2>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">üìò</span>
            <strong>What are Terraform workspaces?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> Workspaces let you manage multiple instances of the same infrastructure using one set of Terraform files. Each workspace has its own state file, so you can have separate dev, staging, and prod environments without duplicating code.</p>

            <p><strong>Why we need it:</strong> Without workspaces, you'd need separate directories for each environment, leading to code duplication and drift. Workspaces let you use the same Terraform code but maintain separate state for each environment. When you switch workspaces, Terraform switches to that environment's state file.</p>

            <p><strong>Key details:</strong> The default workspace is called "default" and always exists. You can reference the current workspace name in code using terraform.workspace. This lets you conditionally change settings per environment, like using smaller instances in dev and larger in prod.</p>

            <p><strong>Common gotcha:</strong> Workspaces share the same backend configuration, so they must be in the same AWS account/region. For multi-account setups (dev and prod in different AWS accounts), you need separate Terraform configurations entirely, not just workspaces.</p>
          </div>
        </div>

        <h3>Step 19: Add Environments with Workspaces</h3>
        <pre><code class="language-bash"># Create production workspace
terraform workspace new prod

# List workspaces
terraform workspace list

# Switch between workspaces
terraform workspace select dev
terraform workspace select prod

# Deploy to prod
terraform apply</code></pre>

        <p>Now you have separate dev and prod environments!</p>

        <h3>Step 20: Use Remote State (S3 Backend)</h3>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">üìò</span>
            <strong>Why store Terraform state in S3?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> By default, Terraform stores state locally in terraform.tfstate files. An S3 backend moves this state to an S3 bucket with optional DynamoDB locking. This is called "remote state" because it's stored remotely instead of on your local machine.</p>

            <p><strong>Why we need it:</strong> Local state doesn't work for teams - if two people run Terraform simultaneously, they could corrupt the state or create conflicting changes. Remote state in S3 provides a single source of truth that everyone accesses. DynamoDB locking prevents simultaneous runs from interfering with each other.</p>

            <p><strong>Key details:</strong> The DynamoDB table only needs one attribute: LockID as a string. When someone runs terraform apply, Terraform writes a lock record to DynamoDB. If someone else tries to run Terraform, they'll see "acquiring state lock" and wait until the first person finishes.</p>

            <p><strong>Common gotcha:</strong> Enable versioning on the S3 bucket! If you accidentally corrupt state, you can restore a previous version. Also enable encryption - state files can contain sensitive data like database passwords or API keys that appear in resource attributes.</p>
          </div>
        </div>

        <p>Create <code>backend.tf</code>:</p>
        <pre><code class="language-terraform">terraform {
  backend "s3" {
    bucket         = "my-terraform-state-bucket"  # Change this!
    key            = "url-shortener/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-state-lock"
  }
}</code></pre>

        <pre><code class="language-bash"># Create S3 bucket for state
aws s3 mb s3://my-terraform-state-bucket-YOUR-NAME

# Create DynamoDB table for locking
aws dynamodb create-table \
  --table-name terraform-state-lock \
  --attribute-definitions AttributeName=LockID,AttributeType=S \
  --key-schema AttributeName=LockID,KeyType=HASH \
  --billing-mode PAY_PER_REQUEST

# Migrate to remote state
terraform init -migrate-state</code></pre>

        <p><strong>Why?</strong></p>
        <ul>
          <li>Team collaboration (shared state)</li>
          <li>State locking (prevents conflicts)</li>
          <li>Secure (state might contain secrets)</li>
        </ul>

        <h3>Step 21: Create Reusable Module</h3>

        <div class="learn-more">
          <div class="learn-more-header">
            <span class="icon">üìò</span>
            <strong>What are Terraform modules?</strong>
          </div>
          <div class="learn-more-content">
            <p><strong>What it is:</strong> A Terraform module is a container for multiple resources that are used together. It's like a function in programming - you define it once with parameters (variables) and can reuse it multiple times. Any directory with .tf files is technically a module, but typically "module" refers to reusable components.</p>

            <p><strong>Why we need it:</strong> Without modules, you'd copy-paste the same Lambda function configuration three times (shorten, redirect, stats). Modules let you write it once and reuse it with different parameters. This reduces duplication, makes updates easier, and enforces consistency across similar resources.</p>

            <p><strong>Key details:</strong> Modules have inputs (variables), resources (what they create), and outputs (values they expose). You call a module with module "name" and pass in variables. The module's outputs become accessible as module.name.output_name. Modules can even call other modules.</p>

            <p><strong>Common gotcha:</strong> After creating or modifying a module, run terraform init to make Terraform aware of it. Also, changes to module source code don't automatically affect existing infrastructure - you still need to run terraform apply. Think of modules as templates, not live code.</p>
          </div>
        </div>

        <p>Create module structure:</p>
        <pre><code class="language-bash">mkdir -p modules/lambda-function</code></pre>

        <p>Create <code>modules/lambda-function/main.tf</code>:</p>
        <pre><code class="language-terraform">resource "aws_lambda_function" "this" {
  filename         = var.filename
  function_name    = var.function_name
  role            = var.role_arn
  handler         = var.handler
  runtime         = var.runtime
  timeout         = var.timeout
  memory_size     = var.memory_size
  source_code_hash = var.source_code_hash

  environment {
    variables = var.environment_variables
  }
}

resource "aws_lambda_permission" "api_gateway" {
  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.this.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = var.api_gateway_execution_arn
}</code></pre>

        <p>Create <code>modules/lambda-function/variables.tf</code>:</p>
        <pre><code class="language-terraform">variable "filename" {
  type = string
}

variable "function_name" {
  type = string
}

variable "role_arn" {
  type = string
}

variable "handler" {
  type    = string
  default = "index.handler"
}

variable "runtime" {
  type    = string
  default = "nodejs20.x"
}

variable "timeout" {
  type    = number
  default = 10
}

variable "memory_size" {
  type    = number
  default = 256
}

variable "source_code_hash" {
  type = string
}

variable "environment_variables" {
  type    = map(string)
  default = {}
}

variable "api_gateway_execution_arn" {
  type = string
}</code></pre>

        <p>Create <code>modules/lambda-function/outputs.tf</code>:</p>
        <pre><code class="language-terraform">output "function_name" {
  value = aws_lambda_function.this.function_name
}

output "invoke_arn" {
  value = aws_lambda_function.this.invoke_arn
}

output "function_arn" {
  value = aws_lambda_function.this.arn
}</code></pre>

        <p>Use module in <code>main.tf</code>:</p>
        <pre><code class="language-terraform">module "shorten_lambda" {
  source = "./modules/lambda-function"

  filename         = data.archive_file.shorten_lambda.output_path
  function_name    = "${var.project_name}-shorten-${var.environment}"
  role_arn        = aws_iam_role.lambda_role.arn
  source_code_hash = data.archive_file.shorten_lambda.output_base64sha256

  environment_variables = {
    TABLE_NAME = aws_dynamodb_table.url_shortener.name
  }

  api_gateway_execution_arn = aws_api_gateway_rest_api.api.execution_arn
}</code></pre>

        <p><strong>Modules = reusable infrastructure components!</strong></p>
      </div>

      <!-- Navigation -->
      <div class="step-navigation">
        <div class="nav-button-group">
          <a href="lesson-04-5.html" class="btn btn-secondary">‚Üê Previous: Test &amp; Iterate</a>
          <a href="lesson-04-7.html" class="btn btn-primary">Next: Destroy &amp; Rebuild ‚Üí</a>
        </div>
      </div>